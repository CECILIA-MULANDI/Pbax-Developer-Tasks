import { getLookupFn, getDynamicBuilder } from '@polkadot-api/metadata-builders';
import { Bytes, Option, Vector, u32, AccountId, metadata, unifyMetadata } from '@polkadot-api/substrate-bindings';
import { toHex } from '@polkadot-api/utils';
import { map, shareReplay, catchError, of, mergeMap, EMPTY, timer } from 'rxjs';
import { BlockNotPinnedError } from '../errors.mjs';
import { OperationInaccessibleError } from '@polkadot-api/substrate-client';

const versionedArgs = (v) => toHex(u32.enc(v));
const opaqueBytes = Bytes();
const optionalOpaqueBytes = Option(opaqueBytes);
const u32ListDecoder = Vector(u32).dec;
const getRuntimeCreator = (call$) => {
  const getMetadata$ = (getHash) => {
    const recoverCall$ = (method, args) => {
      const hash = getHash();
      return hash ? call$(hash, method, args).pipe(
        catchError((e) => {
          if (e instanceof BlockNotPinnedError)
            return recoverCall$(method, args);
          if (e instanceof OperationInaccessibleError)
            return timer(750).pipe(
              mergeMap(() => recoverCall$(method, args))
            );
          throw e;
        })
      ) : EMPTY;
    };
    const versions = recoverCall$("Metadata_metadata_versions", "").pipe(
      map(u32ListDecoder)
    );
    const v14 = recoverCall$("Metadata_metadata", "").pipe(
      map((x) => {
        const metadataRaw = opaqueBytes.dec(x);
        const metadata$1 = metadata.dec(metadataRaw);
        return { metadata: unifyMetadata(metadata$1), metadataRaw };
      })
    );
    const versioned = (v) => recoverCall$("Metadata_metadata_at_version", versionedArgs(v)).pipe(
      map((x) => {
        const metadataRaw = optionalOpaqueBytes.dec(x);
        const metadata$1 = metadata.dec(metadataRaw);
        return { metadata: unifyMetadata(metadata$1), metadataRaw };
      })
    );
    return versions.pipe(
      catchError(() => of([14])),
      mergeMap(
        (v) => v.includes(16) ? versioned(16) : v.includes(15) ? versioned(15) : v14
      )
    );
  };
  return (getHash) => {
    const initialHash = getHash();
    const usages = /* @__PURE__ */ new Set([initialHash]);
    const runtimeContext$ = getMetadata$(
      getHash
    ).pipe(
      map(({ metadata, metadataRaw }) => {
        const lookup = getLookupFn(metadata);
        const dynamicBuilder = getDynamicBuilder(lookup);
        const events = dynamicBuilder.buildStorage("System", "Events");
        const assetPayment = metadata.extrinsic.signedExtensions.find(
          (x) => x.identifier === "ChargeAssetTxPayment"
        );
        let assetId = null;
        if (assetPayment) {
          const assetTxPayment = lookup(assetPayment.type);
          if (assetTxPayment.type === "struct") {
            const optionalAssetId = assetTxPayment.value.asset_id;
            if (optionalAssetId.type === "option")
              assetId = optionalAssetId.value.id;
          }
        }
        return {
          assetId,
          metadataRaw,
          lookup,
          dynamicBuilder,
          events: {
            key: events.keys.enc(),
            dec: events.value.dec
          },
          accountId: AccountId(dynamicBuilder.ss58Prefix)
        };
      }),
      shareReplay(1)
    );
    const result = {
      at: initialHash,
      runtime: runtimeContext$,
      addBlock: (block) => {
        usages.add(block);
        return result;
      },
      deleteBlocks: (blocks) => {
        blocks.forEach((block) => {
          usages.delete(block);
        });
        return usages.size;
      },
      usages
    };
    runtimeContext$.subscribe({
      error() {
      }
    });
    return result;
  };
};

export { getRuntimeCreator };
//# sourceMappingURL=get-runtime-creator.mjs.map
